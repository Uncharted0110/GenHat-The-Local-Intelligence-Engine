<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mind Map</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      background: #0d0d0d;
    }

    #particle-canvas {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    #mindmap-root {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
    }

    /* React Flow dark theme overrides */
    .react-flow__background {
      background-color: transparent !important;
    }

    .react-flow__controls {
      background: rgba(26, 26, 26, 0.9) !important;
      border: 1px solid #ff8c00 !important;
      border-radius: 8px !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;
    }

    .react-flow__controls-button {
      background: transparent !important;
      border: none !important;
      color: #ff8c00 !important;
      fill: #ff8c00 !important;
    }

    .react-flow__controls-button:hover {
      background: rgba(255, 140, 0, 0.2) !important;
    }

    .react-flow__controls-button svg {
      fill: #ff8c00 !important;
    }

    .react-flow__attribution {
      display: none !important;
    }

    .react-flow__edge-path {
      stroke: #ff8c00 !important;
      stroke-width: 2px !important;
    }

    .react-flow__edge.animated path {
      stroke-dasharray: 5 !important;
      animation: dashdraw 0.5s linear infinite !important;
    }

    @keyframes dashdraw {
      from {
        stroke-dashoffset: 10;
      }
    }

    /* Custom node styles */
    .mindmap-node {
      position: relative;
      display: flex;
      align-items: center;
      padding: 12px 16px;
      background: rgba(26, 26, 26, 0.95);
      border: 2px solid #444;
      border-radius: 12px;
      min-width: 150px;
      max-width: 280px;
      transition: all 0.2s ease;
      backdrop-filter: blur(8px);
    }

    .mindmap-node:hover {
      border-color: rgba(255, 140, 0, 0.6);
      box-shadow: 0 4px 16px rgba(255, 140, 0, 0.2);
    }

    .mindmap-node.selected {
      border-color: #ff8c00;
      box-shadow: 0 0 0 3px rgba(255, 140, 0, 0.3);
    }

    .mindmap-node.root {
      background: linear-gradient(135deg, rgba(255, 140, 0, 0.15) 0%, rgba(255, 107, 0, 0.1) 100%);
      border-color: #ff8c00;
    }

    .mindmap-node .node-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .mindmap-node .node-label {
      color: #e0e0e0;
      font-size: 14px;
      font-weight: 500;
      cursor: text;
      word-wrap: break-word;
    }

    .mindmap-node.root .node-label {
      color: #ff8c00;
      font-size: 16px;
      font-weight: 600;
    }

    .mindmap-node .node-input {
      background: transparent;
      border: none;
      outline: none;
      color: #e0e0e0;
      font-size: 14px;
      font-weight: 500;
      width: 100%;
      font-family: inherit;
    }

    .mindmap-node.root .node-input {
      color: #ff8c00;
      font-size: 16px;
      font-weight: 600;
    }

    .mindmap-node .node-actions {
      display: flex;
      align-items: center;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .mindmap-node:hover .node-actions {
      opacity: 1;
    }

    .mindmap-node .action-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      background: transparent;
      border: none;
      border-radius: 6px;
      color: #888;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .mindmap-node .action-btn:hover {
      background: rgba(255, 140, 0, 0.2);
      color: #ff8c00;
    }

    .mindmap-node .collapse-btn {
      margin-left: 8px;
      color: #666;
    }

    .mindmap-node .collapse-btn:hover {
      color: #ff8c00;
    }

    /* Handle styles */
    .react-flow__handle {
      width: 10px !important;
      height: 10px !important;
      border: 2px solid #0d0d0d !important;
      background: #ff8c00 !important;
    }

    .react-flow__handle-left {
      left: -5px !important;
    }

    .react-flow__handle-right {
      right: -5px !important;
    }

    /* Panel styles */
    .control-panel {
      position: absolute;
      top: 16px;
      right: 16px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }

    .panel-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 8px 12px;
      background: rgba(26, 26, 26, 0.95);
      border: 1px solid #ff8c00;
      border-radius: 8px;
      color: #ff8c00;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(8px);
    }

    .panel-btn:hover {
      background: rgba(255, 140, 0, 0.1);
    }

    .panel-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Title header */
    .mindmap-header {
      position: absolute;
      top: 16px;
      left: 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 20px;
      background: rgba(26, 26, 26, 0.95);
      border: 1px solid #ff8c00;
      border-radius: 12px;
      z-index: 10;
      backdrop-filter: blur(8px);
    }

    .mindmap-header svg {
      width: 24px;
      height: 24px;
      color: #ff8c00;
    }

    .mindmap-header h1 {
      color: #ff8c00;
      font-size: 18px;
      font-weight: 600;
      margin: 0;
    }

    /* Loading state */
    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #ff8c00;
    }

    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid rgba(255, 140, 0, 0.2);
      border-top-color: #ff8c00;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <canvas id="particle-canvas"></canvas>
  <div id="mindmap-root"></div>

  <script>
    // Particle background animation
    (function initParticles() {
      const canvas = document.getElementById('particle-canvas');
      const ctx = canvas.getContext('2d');

      let w, h, particles;
      const particleDistance = 40;
      const mouse = { x: undefined, y: undefined, radius: 100 };

      function resizeReset() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;

        particles = [];
        for (let y = (((h - particleDistance) % particleDistance) + particleDistance) / 2; y < h; y += particleDistance) {
          for (let x = (((w - particleDistance) % particleDistance) + particleDistance) / 2; x < w; x += particleDistance) {
            particles.push(new Particle(x, y));
          }
        }
      }

      function animationLoop() {
        ctx.clearRect(0, 0, w, h);
        for (let i = 0; i < particles.length; i++) {
          particles[i].update();
          particles[i].draw();
        }
        requestAnimationFrame(animationLoop);
      }

      class Particle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = 2;
          this.baseX = this.x;
          this.baseY = this.y;
          this.speed = (Math.random() * 25) + 5;
        }
        draw() {
          ctx.fillStyle = "rgba(255, 140, 0, 0.4)";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.closePath();
          ctx.fill();
        }
        update() {
          const dx = mouse.x - this.x;
          const dy = mouse.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const force = (mouse.radius - distance) / mouse.radius;
          const directionX = dx / distance;
          const directionY = dy / distance;

          if (distance < mouse.radius) {
            this.x -= directionX * force * this.speed;
            this.y -= directionY * force * this.speed;
          } else {
            if (this.x !== this.baseX) {
              this.x -= (this.x - this.baseX) / 10;
            }
            if (this.y !== this.baseY) {
              this.y -= (this.y - this.baseY) / 10;
            }
          }
        }
      }

      resizeReset();
      animationLoop();
      window.addEventListener('resize', resizeReset);
      window.addEventListener('mousemove', (e) => { mouse.x = e.x; mouse.y = e.y; });
      window.addEventListener('mouseout', () => { mouse.x = undefined; mouse.y = undefined; });
    })();
  </script>

  <!-- React and dependencies will be loaded via CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@xyflow/react@12.3.6/dist/umd/index.js"></script>
  <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
  
  <script>
    // MindMap React Application
    const { useState, useCallback, useEffect, useMemo, useRef } = React;
    const { 
      ReactFlow, 
      Controls, 
      Background,
      useNodesState, 
      useEdgesState,
      ReactFlowProvider,
      useReactFlow,
      Handle,
      Position,
      BackgroundVariant
    } = ReactFlowXYFlow;

    // Node dimensions for layout
    const NODE_WIDTH = 200;
    const NODE_HEIGHT = 60;

    // Generate unique ID
    function generateId() {
      return 'node-' + Math.random().toString(36).substr(2, 9);
    }

    // Layout nodes using Dagre
    function getLayoutedElements(nodes, edges) {
      const dagreGraph = new dagre.graphlib.Graph();
      dagreGraph.setDefaultEdgeLabel(() => ({}));
      dagreGraph.setGraph({ rankdir: 'LR', nodesep: 50, ranksep: 100 });

      nodes.forEach((node) => {
        dagreGraph.setNode(node.id, { width: NODE_WIDTH, height: NODE_HEIGHT });
      });

      edges.forEach((edge) => {
        dagreGraph.setEdge(edge.source, edge.target);
      });

      dagre.layout(dagreGraph);

      return {
        nodes: nodes.map((node) => {
          const nodeWithPosition = dagreGraph.node(node.id);
          return {
            ...node,
            position: {
              x: nodeWithPosition.x - NODE_WIDTH / 2,
              y: nodeWithPosition.y - NODE_HEIGHT / 2,
            },
          };
        }),
        edges,
      };
    }

    // Custom MindMap Node Component
    function MindMapNode({ data, id, selected }) {
      const [isEditing, setIsEditing] = useState(false);
      const [label, setLabel] = useState(data.label);
      const inputRef = useRef(null);

      useEffect(() => {
        if (isEditing && inputRef.current) {
          inputRef.current.focus();
          inputRef.current.select();
        }
      }, [isEditing]);

      useEffect(() => {
        setLabel(data.label);
      }, [data.label]);

      const handleDoubleClick = () => {
        setIsEditing(true);
      };

      const handleBlur = () => {
        setIsEditing(false);
        if (label !== data.label) {
          data.onLabelChange?.(id, label);
        }
      };

      const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
          setIsEditing(false);
          if (label !== data.label) {
            data.onLabelChange?.(id, label);
          }
        }
        if (e.key === 'Escape') {
          setLabel(data.label);
          setIsEditing(false);
        }
      };

      const nodeClasses = `mindmap-node ${data.isRoot ? 'root' : ''} ${selected ? 'selected' : ''}`;

      return React.createElement('div', { className: nodeClasses },
        // Left handle (target) - only for non-root nodes
        !data.isRoot && React.createElement(Handle, {
          type: 'target',
          position: Position.Left,
          style: { background: '#ff8c00' }
        }),

        // Node content
        React.createElement('div', { className: 'node-content' },
          isEditing
            ? React.createElement('input', {
                ref: inputRef,
                type: 'text',
                className: 'node-input',
                value: label,
                onChange: (e) => setLabel(e.target.value),
                onBlur: handleBlur,
                onKeyDown: handleKeyDown
              })
            : React.createElement('span', {
                className: 'node-label',
                onDoubleClick: handleDoubleClick
              }, label)
        ),

        // Actions
        React.createElement('div', { className: 'node-actions' },
          // Add child button
          React.createElement('button', {
            className: 'action-btn',
            onClick: (e) => { e.stopPropagation(); data.onAddChild?.(id); },
            title: 'Add child node'
          },
            React.createElement('svg', { viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, width: 16, height: 16 },
              React.createElement('line', { x1: 12, y1: 5, x2: 12, y2: 19 }),
              React.createElement('line', { x1: 5, y1: 12, x2: 19, y2: 12 })
            )
          ),
          // Delete button (not for root)
          !data.isRoot && React.createElement('button', {
            className: 'action-btn',
            onClick: (e) => { e.stopPropagation(); data.onDelete?.(id); },
            title: 'Delete node'
          },
            React.createElement('svg', { viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, width: 16, height: 16 },
              React.createElement('line', { x1: 18, y1: 6, x2: 6, y2: 18 }),
              React.createElement('line', { x1: 6, y1: 6, x2: 18, y2: 18 })
            )
          )
        ),

        // Collapse button (if has children)
        data.hasChildren && React.createElement('button', {
          className: 'action-btn collapse-btn',
          onClick: (e) => { e.stopPropagation(); data.onToggleCollapse?.(id); },
          title: data.collapsed ? 'Expand' : 'Collapse'
        },
          React.createElement('svg', { 
            viewBox: '0 0 24 24', 
            fill: 'none', 
            stroke: 'currentColor', 
            strokeWidth: 2, 
            width: 16, 
            height: 16,
            style: { transform: data.collapsed ? 'rotate(0deg)' : 'rotate(90deg)', transition: 'transform 0.2s' }
          },
            React.createElement('polyline', { points: '9 18 15 12 9 6' })
          )
        ),

        // Right handle (source)
        React.createElement(Handle, {
          type: 'source',
          position: Position.Right,
          style: { background: '#ff8c00' }
        })
      );
    }

    // Node types registry
    const nodeTypes = { mindMap: MindMapNode };

    // Main MindMap Content Component
    function MindMapContent({ initialData, title }) {
      const [nodes, setNodes, onNodesChange] = useNodesState([]);
      const [edges, setEdges, onEdgesChange] = useEdgesState([]);
      const [treeData, setTreeData] = useState(initialData);
      const { fitView } = useReactFlow();

      // Add child node
      const handleAddChild = useCallback((parentId) => {
        const newChild = {
          id: generateId(),
          label: 'New Node',
          collapsed: false,
          children: []
        };

        const addNode = (node) => {
          if (node.id === parentId) {
            return { ...node, collapsed: false, children: [...node.children, newChild] };
          }
          return { ...node, children: node.children.map(addNode) };
        };

        setTreeData((prev) => addNode(prev));
      }, []);

      // Toggle collapse
      const handleToggleCollapse = useCallback((nodeId) => {
        const toggle = (node) => {
          if (node.id === nodeId) {
            return { ...node, collapsed: !node.collapsed };
          }
          return { ...node, children: node.children.map(toggle) };
        };
        setTreeData((prev) => toggle(prev));
      }, []);

      // Update label
      const handleLabelChange = useCallback((nodeId, newLabel) => {
        const update = (node) => {
          if (node.id === nodeId) {
            return { ...node, label: newLabel };
          }
          return { ...node, children: node.children.map(update) };
        };
        setTreeData((prev) => update(prev));
      }, []);

      // Delete node
      const handleDelete = useCallback((nodeId) => {
        const remove = (node) => {
          return {
            ...node,
            children: node.children.filter(c => c.id !== nodeId).map(remove)
          };
        };
        setTreeData((prev) => remove(prev));
      }, []);

      // Process tree into nodes and edges
      const processTree = useCallback((tree) => {
        const newNodes = [];
        const newEdges = [];

        const traverse = (node, parentId) => {
          newNodes.push({
            id: node.id,
            type: 'mindMap',
            data: {
              label: node.label,
              isRoot: !parentId,
              collapsed: node.collapsed,
              hasChildren: node.children.length > 0,
              onAddChild: handleAddChild,
              onToggleCollapse: handleToggleCollapse,
              onLabelChange: handleLabelChange,
              onDelete: handleDelete
            },
            position: { x: 0, y: 0 }
          });

          if (parentId) {
            newEdges.push({
              id: `e-${parentId}-${node.id}`,
              source: parentId,
              target: node.id,
              type: 'smoothstep',
              animated: true,
              style: { stroke: '#ff8c00', strokeWidth: 2 }
            });
          }

          if (!node.collapsed) {
            node.children.forEach((child) => traverse(child, node.id));
          }
        };

        traverse(tree);
        return { nodes: newNodes, edges: newEdges };
      }, [handleAddChild, handleToggleCollapse, handleLabelChange, handleDelete]);

      // Update React Flow when tree changes
      useEffect(() => {
        const { nodes: processedNodes, edges: processedEdges } = processTree(treeData);
        const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(processedNodes, processedEdges);
        setNodes(layoutedNodes);
        setEdges(layoutedEdges);
      }, [treeData, processTree, setNodes, setEdges]);

      // Fit view after initial render
      useEffect(() => {
        const timer = setTimeout(() => fitView({ padding: 0.2, duration: 500 }), 100);
        return () => clearTimeout(timer);
      }, [fitView]);

      const handleFitView = () => {
        fitView({ padding: 0.2, duration: 500 });
      };

      return React.createElement('div', { style: { width: '100%', height: '100%' } },
        // Header
        React.createElement('div', { className: 'mindmap-header' },
          React.createElement('svg', { viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
            React.createElement('circle', { cx: 12, cy: 5, r: 3 }),
            React.createElement('circle', { cx: 6, cy: 12, r: 3 }),
            React.createElement('circle', { cx: 18, cy: 12, r: 3 }),
            React.createElement('circle', { cx: 9, cy: 20, r: 3 }),
            React.createElement('circle', { cx: 15, cy: 20, r: 3 }),
            React.createElement('line', { x1: 12, y1: 8, x2: 6, y2: 9 }),
            React.createElement('line', { x1: 12, y1: 8, x2: 18, y2: 9 }),
            React.createElement('line', { x1: 6, y1: 15, x2: 9, y2: 17 }),
            React.createElement('line', { x1: 18, y1: 15, x2: 15, y2: 17 })
          ),
          React.createElement('h1', null, title)
        ),

        // Control panel
        React.createElement('div', { className: 'control-panel' },
          React.createElement('button', { className: 'panel-btn', onClick: handleFitView },
            React.createElement('svg', { viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2 },
              React.createElement('path', { d: 'M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7' })
            ),
            'Fit View'
          )
        ),

        // React Flow canvas
        React.createElement(ReactFlow, {
          nodes: nodes,
          edges: edges,
          onNodesChange: onNodesChange,
          onEdgesChange: onEdgesChange,
          nodeTypes: nodeTypes,
          fitView: true,
          minZoom: 0.1,
          maxZoom: 2,
          defaultEdgeOptions: {
            type: 'smoothstep',
            animated: true,
            style: { strokeWidth: 2, stroke: '#ff8c00' }
          }
        },
          React.createElement(Background, { 
            variant: BackgroundVariant.Dots, 
            gap: 20, 
            size: 1, 
            color: 'rgba(255, 140, 0, 0.15)' 
          }),
          React.createElement(Controls, { showInteractive: false })
        )
      );
    }

    // Main App wrapper with ReactFlowProvider
    function MindMapApp({ initialData, title }) {
      return React.createElement(ReactFlowProvider, null,
        React.createElement(MindMapContent, { initialData, title })
      );
    }

    // Initialize the app when data is received
    function initMindMap(data, title) {
      const root = ReactDOM.createRoot(document.getElementById('mindmap-root'));
      root.render(React.createElement(MindMapApp, { initialData: data, title: title }));
    }

    // Show loading state initially
    function showLoading() {
      document.getElementById('mindmap-root').innerHTML = `
        <div class="loading-container">
          <div class="loading-spinner"></div>
          <p style="margin-top: 16px; font-size: 14px;">Loading mind map...</p>
        </div>
      `;
    }

    // Get data from URL params or window.mindmapData
    document.addEventListener('DOMContentLoaded', () => {
      showLoading();
      
      // Check if data is passed via window object
      if (window.mindmapData) {
        initMindMap(window.mindmapData.tree, window.mindmapData.title);
      } else {
        // Fallback demo data
        const demoData = {
          id: 'root',
          label: 'Central Topic',
          collapsed: false,
          children: [
            {
              id: '1',
              label: 'Main Concept 1',
              collapsed: false,
              children: [
                { id: '1-1', label: 'Detail A', collapsed: false, children: [] },
                { id: '1-2', label: 'Detail B', collapsed: false, children: [] }
              ]
            },
            {
              id: '2',
              label: 'Main Concept 2',
              collapsed: false,
              children: []
            }
          ]
        };
        initMindMap(demoData, 'Demo Mind Map');
      }
    });

    // Listen for postMessage from parent window
    window.addEventListener('message', (event) => {
      if (event.data && event.data.type === 'MINDMAP_DATA') {
        initMindMap(event.data.tree, event.data.title);
      }
    });
  </script>
</body>
</html>
